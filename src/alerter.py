"""Alert system for credit spread notifications via email and Slack."""

import os
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
from pathlib import Path

import requests

from src.models import CreditSpread, AlertConfig
from src.config import load_alert_config


class AlertError(Exception):
    """Custom exception for alert failures."""

    pass


def create_email_body(spreads: list[CreditSpread]) -> str:
    """
    Generate HTML email body with spread details.

    Args:
        spreads: List of credit spreads to include

    Returns:
        HTML string for email body
    """
    html = f"""
    <html>
    <head>
        <style>
            body {{ font-family: Arial, sans-serif; }}
            table {{ border-collapse: collapse; width: 100%; margin-top: 10px; }}
            th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
            th {{ background-color: #4CAF50; color: white; }}
            tr:nth-child(even) {{ background-color: #f2f2f2; }}
            .high-ror {{ background-color: #90EE90; }}
            .summary {{ background-color: #f0f8ff; padding: 10px; border-radius: 5px; margin-bottom: 15px; }}
        </style>
    </head>
    <body>
        <h2>Credit Spread Opportunities</h2>

        <div class="summary">
            <strong>Summary:</strong> Found {len(spreads)} qualifying spread(s)
        </div>

        <p>Top {min(10, len(spreads))} opportunities shown below:</p>

        <table>
            <tr>
                <th>Ticker</th>
                <th>Type</th>
                <th>Strikes</th>
                <th>Credit</th>
                <th>ROR %</th>
                <th>Max Loss</th>
                <th>DTE</th>
                <th>Break-Even</th>
            </tr>
    """

    for spread in spreads[:10]:
        row_class = 'class="high-ror"' if spread.return_on_risk > 35 else ""
        html += f"""
            <tr {row_class}>
                <td><b>{spread.ticker}</b></td>
                <td>{spread.spread_type.replace('_', ' ').title()}</td>
                <td>${spread.short_leg.strike:.0f}/${spread.long_leg.strike:.0f}</td>
                <td>${spread.net_credit:.2f}</td>
                <td><b>{spread.return_on_risk:.1f}%</b></td>
                <td>${spread.max_loss:.2f}</td>
                <td>{spread.days_to_expiration}</td>
                <td>${spread.break_even:.2f}</td>
            </tr>
        """

    html += """
        </table>

        <p style="margin-top: 20px; font-size: 12px; color: #666;">
            <i>Generated by Options Credit Spread Screener</i>
        </p>
    </body>
    </html>
    """

    return html


def send_email_alert(
    spreads: list[CreditSpread],
    alert_config: AlertConfig | None = None,
    dashboard_path: str | None = None,
    subject: str | None = None,
) -> None:
    """
    Send email via Gmail SMTP with optional dashboard attachment.

    Args:
        spreads: List of credit spreads to alert about
        alert_config: Alert configuration (uses env vars if not provided)
        dashboard_path: Optional path to dashboard HTML to attach
        subject: Optional custom subject line

    Raises:
        AlertError: If email sending fails
    """
    if alert_config is None:
        alert_config = load_alert_config()

    if not alert_config.email_configured:
        raise AlertError(
            "Email not configured. Set GMAIL_ADDRESS, GMAIL_APP_PASSWORD, and ALERT_EMAIL."
        )

    if subject is None:
        subject = f"{len(spreads)} High-Quality Credit Spreads Found"

    msg = MIMEMultipart()
    msg["Subject"] = subject
    msg["From"] = alert_config.gmail_address
    msg["To"] = alert_config.alert_email

    # Create HTML body
    body = create_email_body(spreads)
    msg.attach(MIMEText(body, "html"))

    # Attach dashboard if provided
    if dashboard_path and Path(dashboard_path).exists():
        with open(dashboard_path, "rb") as f:
            part = MIMEBase("application", "octet-stream")
            part.set_payload(f.read())
            encoders.encode_base64(part)
            part.add_header(
                "Content-Disposition",
                f'attachment; filename="dashboard.html"',
            )
            msg.attach(part)

    try:
        with smtplib.SMTP_SSL("smtp.gmail.com", 465) as server:
            server.login(alert_config.gmail_address, alert_config.gmail_app_password)
            server.send_message(msg)
    except smtplib.SMTPAuthenticationError as e:
        raise AlertError(f"Gmail authentication failed: {e}")
    except smtplib.SMTPException as e:
        raise AlertError(f"Failed to send email: {e}")


def create_slack_blocks(
    spreads: list[CreditSpread],
    dashboard_path: str | None = None,
) -> list[dict]:
    """
    Create Slack Block Kit message structure.

    Args:
        spreads: List of credit spreads
        dashboard_path: Optional dashboard path to mention

    Returns:
        List of Slack blocks
    """
    blocks = [
        {
            "type": "header",
            "text": {
                "type": "plain_text",
                "text": f"{len(spreads)} Credit Spreads Found",
                "emoji": True,
            },
        },
        {
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": f"*Top {min(5, len(spreads))} opportunities by Return on Risk*",
            },
        },
        {"type": "divider"},
    ]

    for i, spread in enumerate(spreads[:5], 1):
        blocks.append(
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": (
                        f"*{i}. {spread.ticker}* - {spread.spread_type.replace('_', ' ').title()}\n"
                        f"Strikes: `${spread.short_leg.strike:.0f}/${spread.long_leg.strike:.0f}` | "
                        f"Credit: `${spread.net_credit:.2f}` | "
                        f"ROR: *{spread.return_on_risk:.1f}%* | "
                        f"DTE: {spread.days_to_expiration}"
                    ),
                },
            }
        )

    if dashboard_path:
        blocks.extend(
            [
                {"type": "divider"},
                {
                    "type": "context",
                    "elements": [
                        {
                            "type": "mrkdwn",
                            "text": f"Dashboard saved to: `{dashboard_path}`",
                        }
                    ],
                },
            ]
        )

    return blocks


def send_slack_alert(
    spreads: list[CreditSpread],
    alert_config: AlertConfig | None = None,
    dashboard_path: str | None = None,
) -> None:
    """
    Send alert to Slack via webhook.

    Args:
        spreads: List of credit spreads to alert about
        alert_config: Alert configuration (uses env vars if not provided)
        dashboard_path: Optional path to dashboard to mention

    Raises:
        AlertError: If Slack message fails to send
    """
    if alert_config is None:
        alert_config = load_alert_config()

    if not alert_config.slack_configured:
        raise AlertError("Slack not configured. Set SLACK_WEBHOOK_URL.")

    blocks = create_slack_blocks(spreads, dashboard_path)

    try:
        response = requests.post(
            alert_config.slack_webhook_url,
            json={"blocks": blocks},
            timeout=10,
        )
        response.raise_for_status()
    except requests.RequestException as e:
        raise AlertError(f"Failed to send Slack message: {e}")


def send_alerts(
    spreads: list[CreditSpread],
    enable_email: bool = False,
    enable_slack: bool = False,
    dashboard_path: str | None = None,
) -> dict[str, bool]:
    """
    Send alerts through configured channels.

    Args:
        spreads: List of credit spreads to alert about
        enable_email: Whether to send email alerts
        enable_slack: Whether to send Slack alerts
        dashboard_path: Optional dashboard path

    Returns:
        Dictionary with status of each alert channel
    """
    results = {"email": False, "slack": False}
    alert_config = load_alert_config()

    if enable_email and alert_config.email_configured:
        try:
            send_email_alert(spreads, alert_config, dashboard_path)
            results["email"] = True
        except AlertError as e:
            print(f"Email alert failed: {e}")

    if enable_slack and alert_config.slack_configured:
        try:
            send_slack_alert(spreads, alert_config, dashboard_path)
            results["slack"] = True
        except AlertError as e:
            print(f"Slack alert failed: {e}")

    return results


def test_email_connection() -> bool:
    """
    Test email configuration and connection.

    Returns:
        True if connection successful
    """
    alert_config = load_alert_config()

    if not alert_config.email_configured:
        print("Email not configured")
        return False

    try:
        with smtplib.SMTP_SSL("smtp.gmail.com", 465) as server:
            server.login(alert_config.gmail_address, alert_config.gmail_app_password)
        print("Email connection successful")
        return True
    except Exception as e:
        print(f"Email connection failed: {e}")
        return False


def test_slack_connection() -> bool:
    """
    Test Slack webhook configuration.

    Returns:
        True if test message sent successfully
    """
    alert_config = load_alert_config()

    if not alert_config.slack_configured:
        print("Slack not configured")
        return False

    try:
        response = requests.post(
            alert_config.slack_webhook_url,
            json={"text": "Test message from Options Screener"},
            timeout=10,
        )
        response.raise_for_status()
        print("Slack connection successful")
        return True
    except Exception as e:
        print(f"Slack connection failed: {e}")
        return False
